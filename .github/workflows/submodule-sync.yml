name: 🔄 Submodule Sync

on:
  schedule:
    # Run every day at 02:00 UTC
    - cron: "0 2 * * *"
  push:
    branches: [main, master]
    paths:
      - ".gitmodules"
      - "secret"
  workflow_dispatch:
    inputs:
      force_sync:
        description: "Force sync even if no changes detected"
        required: false
        default: false
        type: boolean

jobs:
  sync-submodule:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: read

    steps:
      - name: 📥 Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.SUBMODULE_TOKEN || secrets.GITHUB_TOKEN }}}
          submodules: recursive
          fetch-depth: 0

      - name: 🔧 Configure Git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: 🔍 Check Submodule Status
        id: submodule-status
        run: |
          echo "🔍 Checking submodule status..."

          if [ ! -d "secret" ]; then
            echo "❌ Secret submodule not found!"
            echo "submodule_exists=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "submodule_exists=true" >> $GITHUB_OUTPUT

          # Check if submodule is properly initialized
          cd secret
          if [ ! -f ".git" ] && [ ! -d ".git" ]; then
            echo "⚠️ Submodule not properly initialized"
            echo "submodule_initialized=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "submodule_initialized=true" >> $GITHUB_OUTPUT

          # Get current submodule commit
          current_commit=$(git rev-parse HEAD)
          echo "current_commit=$current_commit" >> $GITHUB_OUTPUT
          echo "📍 Current submodule commit: $current_commit"

          # Check for updates in remote
          git fetch origin
          latest_commit=$(git rev-parse origin/main || git rev-parse origin/master)
          echo "latest_commit=$latest_commit" >> $GITHUB_OUTPUT
          echo "📍 Latest remote commit: $latest_commit"

          if [ "$current_commit" != "$latest_commit" ]; then
            echo "🔄 Submodule updates available"
            echo "updates_available=true" >> $GITHUB_OUTPUT
          else
            echo "✅ Submodule is up to date"
            echo "updates_available=false" >> $GITHUB_OUTPUT
          fi

      - name: 🔄 Update Submodule
        if: steps.submodule-status.outputs.updates_available == 'true' || github.event.inputs.force_sync == 'true'
        run: |
          echo "🔄 Updating submodule..."

          # Update submodule to latest commit
          git submodule update --remote --merge secret

          # Check if there are changes to commit
          if git diff --quiet && git diff --staged --quiet; then
            echo "ℹ️ No changes after submodule update"
            echo "changes_made=false" >> $GITHUB_ENV
          else
            echo "📝 Changes detected after submodule update"
            echo "changes_made=true" >> $GITHUB_ENV
          fi

      - name: 🔍 Analyze Configuration Differences
        if: steps.submodule-status.outputs.submodule_exists == 'true'
        run: |
          python3 << 'EOF'
          import os
          import json
          import difflib
          from pathlib import Path

          def compare_configs():
              """Compare public and private configurations"""
              differences = []

              # Find corresponding config files
              public_configs = []
              private_configs = []

              # Scan for public configs
              for root, dirs, files in os.walk('.'):
                  if 'secret' in root or '.git' in root:
                      continue
                  for file in files:
                      if file.endswith(('.json', '.yml', '.yaml')) or file == 'config':
                          public_configs.append(os.path.join(root, file))

              # Scan for private configs
              if os.path.exists('secret'):
                  for root, dirs, files in os.walk('secret'):
                      if '.git' in root:
                          continue
                      for file in files:
                          if file.endswith(('.json', '.yml', '.yaml')) or file == 'config':
                              private_configs.append(os.path.join(root, file))

              # Compare corresponding files
              for public_config in public_configs:
                  # Find corresponding private config
                  rel_path = os.path.relpath(public_config, '.')
                  private_config = os.path.join('secret', rel_path)

                  if os.path.exists(private_config):
                      print(f"🔍 Comparing: {rel_path}")

                      try:
                          with open(public_config, 'r') as f:
                              public_content = f.read()
                          with open(private_config, 'r') as f:
                              private_content = f.read()

                          # Basic structure comparison (ignoring sensitive values)
                          if public_config.endswith('.json'):
                              try:
                                  public_json = json.loads(public_content)
                                  private_json = json.loads(private_content)

                                  # Check if structures match (ignoring values with secrets)
                                  public_structure = get_structure_without_secrets(public_json)
                                  private_structure = get_structure_without_secrets(private_json)

                                  if public_structure != private_structure:
                                      differences.append(f"Structure mismatch in {rel_path}")

                              except json.JSONDecodeError:
                                  print(f"⚠️ JSON parsing failed for {rel_path}")

                          # Count placeholder vs real values
                          placeholder_count = public_content.count('<') + public_content.count('>')
                          print(f"  📊 Placeholders in public: {placeholder_count // 2}")

                      except Exception as e:
                          print(f"❌ Error comparing {rel_path}: {e}")
                          differences.append(f"Error comparing {rel_path}: {e}")
                  else:
                      print(f"⚠️ No private equivalent for: {rel_path}")
                      differences.append(f"Missing private config: {rel_path}")

              return differences

          def get_structure_without_secrets(obj, path=""):
              """Get object structure while ignoring secret values"""
              if isinstance(obj, dict):
                  result = {}
                  for key, value in obj.items():
                      if any(secret_word in key.lower() for secret_word in ['token', 'key', 'secret', 'password']):
                          result[key] = "<SECRET>"
                      else:
                          result[key] = get_structure_without_secrets(value, f"{path}.{key}")
                  return result
              elif isinstance(obj, list):
                  return [get_structure_without_secrets(item, f"{path}[{i}]") for i, item in enumerate(obj)]
              else:
                  return type(obj).__name__

          print("🔍 Analyzing configuration differences...")
          differences = compare_configs()

          if differences:
              print(f"\n⚠️ Found {len(differences)} differences:")
              for diff in differences:
                  print(f"  - {diff}")
          else:
              print("\n✅ All configurations are properly synchronized!")

          # Save results for later steps
          with open('config_analysis.txt', 'w') as f:
              f.write(f"Configuration Analysis Results\n")
              f.write(f"==============================\n\n")
              if differences:
                  f.write(f"Differences found: {len(differences)}\n\n")
                  for diff in differences:
                      f.write(f"- {diff}\n")
              else:
                  f.write("✅ All configurations are synchronized\n")
          EOF

      - name: 📤 Commit Submodule Updates
        if: env.changes_made == 'true'
        run: |
          echo "📤 Committing submodule updates..."

          # Add submodule changes
          git add secret

          # Create commit message
          commit_msg="🔄 Auto-sync secret submodule

          - Updated to latest commit: ${{ steps.submodule-status.outputs.latest_commit }}
          - Previous commit: ${{ steps.submodule-status.outputs.current_commit }}
          - Sync performed: $(date -u)

          [skip ci]"

          git commit -m "$commit_msg"

          echo "✅ Submodule update committed"

      - name: 🚀 Push Changes
        if: env.changes_made == 'true'
        run: |
          echo "🚀 Pushing changes..."
          git push origin ${{ github.ref_name }}
          echo "✅ Changes pushed successfully"

      - name: 📊 Generate Sync Report
        if: always()
        run: |
          echo "📊 Submodule Sync Report" | tee sync_report.md
          echo "========================" | tee -a sync_report.md
          echo "" | tee -a sync_report.md

          echo "**Sync Details:**" | tee -a sync_report.md
          echo "- Repository: ${{ github.repository }}" | tee -a sync_report.md
          echo "- Branch: ${{ github.ref_name }}" | tee -a sync_report.md
          echo "- Triggered by: ${{ github.event_name }}" | tee -a sync_report.md
          echo "- Timestamp: $(date -u)" | tee -a sync_report.md
          echo "" | tee -a sync_report.md

          if [ "${{ steps.submodule-status.outputs.submodule_exists }}" == "true" ]; then
            echo "**Submodule Status:**" | tee -a sync_report.md
            echo "- Submodule exists: ✅" | tee -a sync_report.md
            echo "- Properly initialized: ${{ steps.submodule-status.outputs.submodule_initialized == 'true' && '✅' || '❌' }}" | tee -a sync_report.md
            echo "- Updates available: ${{ steps.submodule-status.outputs.updates_available == 'true' && '🔄' || '✅' }}" | tee -a sync_report.md
            echo "- Changes committed: ${{ env.changes_made == 'true' && '✅' || 'ℹ️ No changes' }}" | tee -a sync_report.md
          else
            echo "**Submodule Status:**" | tee -a sync_report.md
            echo "- Submodule exists: ❌" | tee -a sync_report.md
          fi

          echo "" | tee -a sync_report.md

          if [ -f config_analysis.txt ]; then
            echo "**Configuration Analysis:**" | tee -a sync_report.md
            echo '```' | tee -a sync_report.md
            cat config_analysis.txt | tee -a sync_report.md
            echo '```' | tee -a sync_report.md
          fi

          echo "" | tee -a sync_report.md
          echo "---" | tee -a sync_report.md
          echo "*Report generated by GitHub Actions*" | tee -a sync_report.md

      - name: 📧 Create Issue on Sync Failure
        if: failure() && github.event_name == 'schedule'
        uses: actions/github-script@v7
        with:
          script: |
            const title = '🚨 Submodule Sync Failed';
            const body = `## Submodule Sync Failure Report

            The scheduled submodule sync has failed.

            **Details:**
            - Repository: ${{ github.repository }}
            - Branch: ${{ github.ref_name }}
            - Workflow Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
            - Timestamp: ${new Date().toUTCString()}

            **Possible Issues:**
            - Authentication problems with private submodule
            - Network connectivity issues
            - Submodule repository access permissions
            - Configuration conflicts

            **Next Steps:**
            1. Check the workflow logs for detailed error information
            2. Verify submodule access permissions
            3. Manually trigger the sync workflow if needed
            4. Update authentication tokens if expired

            This issue was created automatically by the submodule sync workflow.
            `;

            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['automation', 'submodule', 'sync-failure']
            });

      - name: 🧹 Cleanup
        if: always()
        run: |
          # Clean up temporary files
          rm -f config_analysis.txt sync_report.md
          echo "🧹 Cleanup completed"
